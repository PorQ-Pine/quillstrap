use std::fs::remove_dir_all;

use crate::prelude::*;

const BASE_ROOTFS_URL: &str = "https://images.linuxcontainers.org/images/fedora/42/arm64/default/";
const RESOLV_FILE: &str = "# Generated by quillstrap\n\nnameserver 1.1.1.1\nnameserver 8.8.8.8\n";

#[derive(Clone, Copy, Default)]
pub struct Rootfs;

impl Rootfs {
    pub fn execute(dir: &str, command: &str, show_output: bool) {
        // let thing = get_thing_by_name("rootfs", &_options.things);
        let cur_dir = dir_current();
        run_command(&format!("chroot {} {}", dir, command), show_output).unwrap();
        dir_change(&cur_dir);
    }

    // Dir, with / at the end
    pub fn turn_on_chroot(dir: &str) {
        umount_recursive(dir);
        mount_point(&format!("{}proc", dir), "proc");
        mount_point(&format!("{}sys", dir), "sysfs");
        mount_point(&format!("{}tmp", dir), "tmpfs");
        mount_point(&format!("{}run", dir), "tmpfs");
        mount_point(&format!("{}dev", dir), "devtmpfs");
        /*
        let dev_pts_path = &format!("{}dev/pts", dir);
        mkdir_p(dev_pts_path);
        mount_point(dev_pts_path, "devpts");
        */
        let resolv_file = &format!("{}/etc/resolv.conf", dir);
        remove_file(resolv_file).ok();
        let mut file = File::create(resolv_file).unwrap();
        file.write_all(RESOLV_FILE.as_bytes()).unwrap();
        file.flush().unwrap();
    }

    pub fn disable_service(dir: &str, service: &str) {
        Rootfs::execute(dir, &format!("systemctl disable {}", service), false);
        Rootfs::execute(dir, &format!("systemctl mask {}", service), false);
    }
}

impl SetupThing for Rootfs {
    fn name(&self) -> &'static str {
        "rootfs"
    }

    fn path(&self) -> &'static str {
        "os/low/"
    }

    fn deps(&self) -> Vec<&'static str> {
        vec!["rootfs_configs"]
    }

    fn git(&self) -> &'static str {
        todo!()
    }

    fn get(&self, _options: &crate::Options) -> color_eyre::eyre::Result<(), String> {
        mkdir_p(self.name());
        dir_change(self.name());

        if path_exists("rootfs.tar.xz") && path_exists("rootfs") {
            warn!("Rootfs file and dir already present. We won't redownload them, use clean if you want to force this");
            return Ok(());
        }

        remove_file("rootfs.tar.xz").ok();
        remove_dir_all("rootfs").ok();

        let mut ver = run_shell_command_get_output(&format!(
            "curl -s {} | grep href | tail -n 3 | cut -c 10-25 | tail -n 1",
            BASE_ROOTFS_URL
        ));
        ver.pop();
        info!("Downloading container version: {}", ver);
        download_file(
            &format!("{}{}/rootfs.tar.xz", BASE_ROOTFS_URL, ver),
            "rootfs.tar.xz",
        );

        mkdir_p("rootfs");
        run_command(
            &format!("tar -xJf rootfs.tar.xz -C rootfs"),
            _options.config.command_output,
        )
        .unwrap();

        dir_change("../");
        Ok(())
    }

    fn clean(&self) -> color_eyre::eyre::Result<(), String> {
        todo!()
    }

    fn build(&self, _options: &crate::Options) -> color_eyre::eyre::Result<(), String> {
        const RD: &str = "rootfs/";
        Rootfs::turn_on_chroot(RD);

        // Packages
        Rootfs::execute(RD, "dnf --assumeyes update", true);
        let packages: Vec<&str> = vec![
            "zsh",
            "NetworkManager",
            "NetworkManager-wifi",
            "vim",
            "nano",
            "busybox",
        ];
        Rootfs::execute(
            RD,
            &format!("dnf --assumeyes install {}", packages.join(" ")),
            true,
        );

        // Files and dirs
        if _options.config.unrestricted {
            // For now, no
            // File::create(&format!("{}.unrestricted", RD)).unwrap();
        }
        mkdir_p(&format!("{}lib/modules", RD));
        mkdir_p(&format!("{}lib/firmware", RD));
        clean_dir(&format!("{}var/log", RD));
        clean_dir(&format!("{}var/cache", RD));

        // Services
        Rootfs::disable_service(RD, "systemd-networkd-wait-online");
        Rootfs::disable_service(RD, "systemd-time-wait-sync");
        Rootfs::disable_service(RD, "serial-getty@");
        Rootfs::disable_service(RD, "getty@tty1");

        // Configs from other repo
        copy_dir_content("../rootfs_configs/common", RD);
        if _options.config.unrestricted {
            copy_dir_content("../rootfs_configs/unrestricted", RD);
        } else {
            copy_dir_content("../rootfs_configs/restricted", RD);
        }

        // Other configs, manually
        // Dropbear
        if _options.config.unrestricted {
            run_command(
                &format!(
                    "ln -s ../../boot/rsa_hkey {}etc/dropbear/dropbear_rsa_host_key",
                    RD
                ),
                _options.config.command_output,
            )
            .unwrap();
            run_command(
                &format!(
                    "ln -s ../../boot/rsa_hkey.pub {}etc/dropbear/dropbear_rsa_host_key.pub",
                    RD
                ),
                _options.config.command_output,
            )
            .unwrap();
        }

        // Root password (for now at least)
        if _options.config.unrestricted {
            let pass_hash = run_command_get_output("openssl passwd -1 root");
            Rootfs::execute(RD, &format!("usermod --password {} root", pass_hash), true);
        }

        // Other
        replace_string_file(
            &format!("{}etc/os-release", RD),
            "Fedora Linux 42 (Container Image)",
            "Quill OS",
        );

        // Cleanout
        umount_recursive(RD);
        remove_files_recursive(RD, ".gitkeep");

        // Compress
        mkdir_p("out");
        remove_file("out/rootfs.squashfs").ok();
        remove_file("out/rootfs.squashfs.dgst").ok();

        run_command(&format!("mksquashfs {} out/rootfs.squashfs -b 32768 -comp zstd -Xcompression-level 22 -no-xattrs", RD), true).unwrap();
        // Sign
        sign("out/rootfs.squashfs", "out/rootfs.squashfs.dgst", _options);
        Ok(())
    }

    fn deploy(&self, _options: &crate::Options) -> color_eyre::eyre::Result<(), String> {
        warn!("We assume because of expose_mmc deploy, the mmc is exposed as a block device");

        let _disk = choose_disk();
        let partition = get_partition("quill_main");
        mkdir_p("/mnt/quill_main");
        run_command(
            &format!("mount {} /mnt/quill_main", partition),
            _options.config.command_output,
        )
        .unwrap();
        run_command("sync", false).unwrap();
        // Copy things
        mkdir_p("/mnt/quill_main/system");
        remove_file("/mnt/quill_main/system/rootfs.squashfs").ok();
        remove_file("/mnt/quill_main/system/rootfs.squashfs.dgst").ok();
        copy_file("out/rootfs.squashfs", "/mnt/quill_main/system/rootfs.squashfs").unwrap();
        copy_file("out/rootfs.squashfs.dgst", "/mnt/quill_main/system/rootfs.squashfs.dgst").unwrap();

        if !path_exists("/mnt/quill_main/system/rootfs.squashfs") || !path_exists("/mnt/quill_main/system/rootfs.squashfs.dgst") {
            panic!("Failed to copy rootfs filesystem to pinenote");
        }

        run_command("sync", false).unwrap();
        run_command(
            &format!("umount {}", partition),
            _options.config.command_output,
        )
        .unwrap();
        Ok(())
    }

    fn run(&self) -> color_eyre::eyre::Result<(), String> {
        todo!()
    }
}
