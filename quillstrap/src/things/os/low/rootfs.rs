use std::fs::remove_dir_all;

use crate::prelude::*;

const BASE_ROOTFS_URL: &str = "https://images.linuxcontainers.org/images/fedora/42/arm64/default/";
const RESOLV_FILE: &str = "# Generated by quillstrap\n\nnameserver 1.1.1.1\nnameserver 8.8.8.8\n";

#[derive(Clone, Copy, Default)]
pub struct Rootfs;

impl Rootfs {
    pub fn execute(_options: &crate::Options, dir: &str, command: &str) {
        // let thing = get_thing_by_name("rootfs", &_options.things);
        let cur_dir = dir_current();
        run_command(&format!("chroot {} {}", dir, command), true).unwrap();
        dir_change(&cur_dir);
    }

    // Dir, with / at the end
    pub fn turn_on_chroot(dir: &str) {
        umount_recursive(dir);
        mount_point(&format!("{}proc", dir), "proc");
        mount_point(&format!("{}sys", dir), "sysfs");
        mount_point(&format!("{}tmp", dir), "tmpfs");
        mount_point(&format!("{}run", dir), "tmpfs");
        mount_point(&format!("{}dev", dir), "devtmpfs");
        /*
        let dev_pts_path = &format!("{}dev/pts", dir);
        mkdir_p(dev_pts_path);
        mount_point(dev_pts_path, "devpts");
        */
        let resolv_file = &format!("{}/etc/resolv.conf", dir);
        remove_file(resolv_file).ok();
        let mut file = File::create(resolv_file).unwrap();
        file.write_all(RESOLV_FILE.as_bytes()).unwrap();
        file.flush().unwrap();
    }
}

impl SetupThing for Rootfs {
    fn name(&self) -> &'static str {
        "rootfs"
    }

    fn path(&self) -> &'static str {
        "os/low/"
    }

    fn deps(&self) -> Vec<&'static str> {
        vec![]
    }

    fn git(&self) -> &'static str {
        todo!()
    }

    fn get(&self, _options: &crate::Options) -> color_eyre::eyre::Result<(), String> {
        mkdir_p(self.name());
        dir_change(self.name());

        remove_file("rootfs.tar.xz").ok();
        remove_dir_all("rootfs").ok();

        let mut ver = run_shell_command_get_output(&format!(
            "curl -s {} | grep href | tail -n 3 | cut -c 10-25 | tail -n 1",
            BASE_ROOTFS_URL
        ));
        ver.pop();
        info!("Downloading container version: {}", ver);
        download_file(
            &format!("{}{}/rootfs.tar.xz", BASE_ROOTFS_URL, ver),
            "rootfs.tar.xz",
        );

        mkdir_p("rootfs");
        run_command(
            &format!("tar -xJf rootfs.tar.xz -C rootfs"),
            _options.config.command_output,
        )
        .unwrap();

        dir_change("../");
        Ok(())
    }

    fn clean(&self) -> color_eyre::eyre::Result<(), String> {
        Ok(())
    }

    fn build(&self, _options: &crate::Options) -> color_eyre::eyre::Result<(), String> {
        const RD: &str = "rootfs/";
        Rootfs::turn_on_chroot(RD);

        // Packages
        Rootfs::execute(_options, RD, "dnf --assumeyes update");
        let packages: Vec<&str> = vec!["zsh", "NetworkManager", "NetworkManager-wifi", "vim", "nano", "busybox"];
        Rootfs::execute(_options, RD, &format!("dnf --assumeyes install {}", packages.join(" ")));

        umount_recursive(RD);
        Ok(())
    }

    fn deploy(&self, _options: &crate::Options) -> color_eyre::eyre::Result<(), String> {
        todo!();
    }

    fn run(&self) -> color_eyre::eyre::Result<(), String> {
        todo!()
    }
}
