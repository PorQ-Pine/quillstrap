use std::fs::remove_dir_all;

use crate::prelude::*;

pub const BASE_ROOTFS_URL: &str =
    "https://images.linuxcontainers.org/images/fedora/42/arm64/default/";
pub const ROOTFS_RESOLV_FILE: &str =
    "# Generated by quillstrap\n\nnameserver 1.1.1.1\nnameserver 8.8.8.8\n";

// ZSH is installed in build code seperately in rootfs
const ESSENTIAL_PACKAGES: &[&str] = &[
    "NetworkManager",
    "NetworkManager-wifi",
    "cracklib-dicts",
    "gocryptfs",
    "sudo",
];

// Also installed in sysroot
pub const ROOTFS_PACKAGES_EVERYWHERE: &[&str] = &[
    "busybox",
    "htop",
    "vim",
    "nano",
    "nano-default-editor",
    "less",
    "ncurses",
    // Libs
    "libxkbcommon",
    "libinput-utils",
    "libinput",
    "fontconfig",
    "freetype",
    "mesa-libgbm",
    "pam",
    "pam-libs",
    "libseat",
    "glib2",
    "pipewire",
    "cairo",
    "pango",
    "libdisplay-info",
    "cairo-gobject",
    "gtk3",
    "libdbusmenu",
    "libdbusmenu-gtk3",
    "gtk-layer-shell",
    "libbsd",
];

const ROOTFS_BLACKLIST: &[&str] = &[
    "grub2-*",
    "grubby",
    "kernel-core",
    "kernel-modules",
    "amd-gpu-firmware",
    "intel-gpu-firmware",
    "atheros-firmware",
    "brcmfmac-firmware",
    "iwlwifi-*",
    "libertas-firmware",
    "mt7xxx-firmware",
    "nvidia-gpu-firmware",
    "nxpwireless-firmware",
    "qcom-firmware",
    "qcom-wwan-firmware",
    "realtek-firmware",
    "tiwilink-firmware",
    "intel-audio-firmware",
    "cirrus-audio-firmware",
    "linux-firmware",
    "amd-ucode-firmware",
    "xorg-x11-drv-amdgpu",
    "xorg-x11-drv-ati",
    "xorg-x11-drv-nouveau",
    "xorg-x11-drv-qxl",
    "xorg-x11-drv-wacom",
    "dracut*",
    "fwupd*",
    "plymouth*",
    "zram-generator*",
    "open-vm-tools*",
    "qemu-guest-agent",
    "qemu-img",
    "selinux*",
];

const ROOTFS_GUI_PACKAGES: &[&str] = &[
    "greetd",
    "niri",
    "upower",
    // 2 default terminals
    "alacritty",
    "tilix", // I can't configure it's default terminal font from here... Anyway the gui allows to change it easily
    "bluez",
    "bluez-tools",
    // Breaks bluetoothctl? - seems to work just fine now
    "blueman",
    "dejavu-fonts-all",
    "nwg-drawer",
    "xournalpp",
    "firefox",
    "network-manager-applet",
    "swaybg",
    // Sound
    "pipewire-pulse",
    "pipewire",
    "pulseaudio-utils",
    "rhythmbox", // If someone has a better default music app, let me know ;p
    // File manager
    "krusader",
    // Text editor
    "kate",
    // Audio codecs
    "gstreamer1-plugins-base",
    "gstreamer1-plugins-good",
    "gstreamer1-plugins-bad-free",
    "gstreamer1-plugins-bad-free-extras",
    "gstreamer1-libav",
    // Remote display, best solution that I have found
    "tigervnc", // for vncviewer command
    // Virtual keyboard
    "squeekboard",
    // Fix for Qt stuff
    "qt6-qtwayland",
    "qt5-qtwayland",
    // GTK fix
    "gsettings-desktop-schemas",
    // Pavucontrol fix
    "libglvnd-gles",
    // Remove once login from qinit works, or maybe not, leave it for dev things
    "tuigreet",
    // Eww tools
    "pamixer",
    "dunst",
    "papirus-icon-theme",
    "papirus-icon-theme-dark",
    "playerctl",
    "pavucontrol",
    "rg",
    "jq",
    "gammastep", // For tresholding level
];

#[derive(Clone, Copy, Default, Debug)]
pub struct Rootfs;

impl Rootfs {
    pub fn execute(dir: &str, command: &str, show_output: bool) {
        // let thing = get_thing_by_name("rootfs", &_options.things);
        let cur_dir = dir_current();
        run_command(&format!("chroot {} {}", dir, command), show_output).unwrap();
        dir_change(&cur_dir);
    }

    // Dir, with / at the end
    pub fn turn_on_chroot(dir: &str) {
        umount_recursive(dir);
        mount_point(&format!("{}proc", dir), "proc");
        mount_point(&format!("{}sys", dir), "sysfs");
        mount_point(&format!("{}tmp", dir), "tmpfs");
        mount_point(&format!("{}run", dir), "tmpfs");
        mount_point(&format!("{}dev", dir), "devtmpfs");
        /*
        let dev_pts_path = &format!("{}dev/pts", dir);
        mkdir_p(dev_pts_path);
        mount_point(dev_pts_path, "devpts");
        */
        let resolv_file = &format!("{}/etc/resolv.conf", dir);
        remove_file(resolv_file, false).ok();
        let mut file = File::create(resolv_file).unwrap();
        file.write_all(ROOTFS_RESOLV_FILE.as_bytes()).unwrap();
        file.flush().unwrap();
    }

    pub fn disable_service(dir: &str, service: &str) {
        Rootfs::execute(dir, &format!("systemctl disable {}", service), false);
        Rootfs::execute(dir, &format!("systemctl mask {}", service), false);
    }
}

const RD: &str = "rootfs/";
impl SetupThing for Rootfs {
    fn name(&self) -> &'static str {
        "rootfs"
    }

    fn path(&self) -> &'static str {
        "os/low/"
    }

    fn deps(&self) -> Vec<&'static str> {
        vec![
            "rootfs_configs",
            "greetd",
            "eww_config",
            "eww_data_provider",
            "eww_niri_toolbar",
            "eww",
            "koreader",
            "niri",
            "pinenote_service",
            "qoms",
            "squeekboard",
        ]
    }

    fn git(&self) -> &'static str {
        todo!()
    }

    fn get(&self, _options: &crate::Options) -> color_eyre::eyre::Result<(), String> {
        mkdir_p(self.name());
        dir_change(self.name());

        if path_exists("rootfs.tar.xz") && path_exists("rootfs") {
            warn!(
                "Rootfs file and dir already present. We won't redownload them, use clean if you want to force this"
            );
            dir_change("../");
            return Ok(());
        }

        remove_file("rootfs.tar.xz", false).ok();
        remove_dir_all("rootfs").ok();

        let mut ver = run_shell_command_get_output(&format!(
            "curl -s {} | grep href | tail -n 3 | cut -c 10-25 | tail -n 1",
            BASE_ROOTFS_URL
        ));
        ver.pop();
        info!("Downloading container version: {}", ver);
        download_file(
            &format!("{}{}/rootfs.tar.xz", BASE_ROOTFS_URL, ver),
            "rootfs.tar.xz",
        );

        mkdir_p("rootfs");
        run_command(
            &format!("tar -xJf rootfs.tar.xz -C rootfs"),
            _options.config.command_output,
        )
        .unwrap();

        dir_change("../");
        Ok(())
    }

    fn is_built(&self) -> bool {
        path_exists("out/rootfs.squashfs") && path_exists("out/rootfs.squashfs.dgst")
    }

    fn clean(&self, _options: &Options) -> color_eyre::eyre::Result<(), String> {
        umount_recursive(RD);
        if let Err(err) = remove_dir_all("rootfs/") {
            warn!("Failed to remove rootfs: {:?}", err);
        }
        remove_dir_all("out/").ok();
        remove_file("rootfs.tar.xz", _options.config.command_output).ok();

        Ok(())
    }

    fn build(&self, _options: &crate::Options) -> color_eyre::eyre::Result<(), String> {
        warn!(
            "This is an additive build, if you builded it before with different features, you should clean it now!"
        );

        Rootfs::turn_on_chroot(RD);

        // Eww config coppied to rootfs_configs
        remove_dir_all("../rootfs_configs/common/etc/skel/.config/eww").ok();
        mkdir_p("../rootfs_configs/common/etc/skel/.config/eww");
        copy_dir_content(
            "../../gui/eww_config/",
            "../rootfs_configs/common/etc/skel/.config/eww",
        );
        remove_dir_all("../rootfs_configs/common/etc/skel/.config/eww/.git").ok();

        // Configs from other repo
        copy_dir_content("../rootfs_configs/common", RD);
        if _options.config.unrestricted {
            copy_dir_content("../rootfs_configs/unrestricted", RD);
        } else {
            copy_dir_content("../rootfs_configs/restricted", RD);
        }
        // Copy skel dir to root
        copy_dir_content("../rootfs_configs/common/etc/skel", &format!("{}root/", RD));

        // Apply dnf blacklist
        append_to_file(
            &format!("{}etc/dnf/dnf.conf", RD),
            &format!("exclude=\"{}\"", ROOTFS_BLACKLIST.join(",")),
        );

        // Packages
        Rootfs::execute(RD, "dnf --assumeyes update", true);
        let mut packages = Vec::from(ESSENTIAL_PACKAGES);
        packages.extend(ROOTFS_PACKAGES_EVERYWHERE);
        packages.extend(ROOTFS_GUI_PACKAGES);
        Rootfs::execute(
            RD,
            &format!("dnf --assumeyes install {}", packages.join(" ")),
            true,
        );

        // Files and dirs
        // For now, no
        /*
        if _options.config.unrestricted {
            File::create(&format!("{}.unrestricted", RD)).unwrap();
        }
        */
        mkdir_p(&format!("{}lib/modules", RD));
        mkdir_p(&format!("{}lib/firmware", RD));
        clean_dir(&format!("{}var/log", RD));
        clean_dir(&format!("{}var/cache", RD));

        // Services
        Rootfs::disable_service(RD, "systemd-networkd-wait-online");
        Rootfs::disable_service(RD, "systemd-time-wait-sync");
        Rootfs::disable_service(RD, "serial-getty@");
        // Rootfs::disable_service(RD, "getty@tty1");
        // Don't mask
        Rootfs::execute(RD, &format!("systemctl disable getty@tty1"), false);

        // Zsh
        {
            Rootfs::execute(
                RD,
                &format!(
                    "dnf config-manager addrepo --from-repofile=https://download.opensuse.org/repositories/shells:zsh-users:zsh-autosuggestions/Fedora_Rawhide/shells:zsh-users:zsh-autosuggestions.repo"
                ),
                _options.config.command_output,
            );
            Rootfs::execute(
                RD,
                &format!("dnf --assumeyes install zsh zsh-autosuggestions"),
                _options.config.command_output,
            );
            Rootfs::execute(RD, &format!("chsh -s /usr/bin/zsh root"), true);
            mkdir_p(&format!("{}etc/zsh/zsh-autosuggestions", RD));
            create_file_symlink(
                "/usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh",
                &format!("{}etc/zsh/zsh-autosuggestions/zsh-autosuggestions.zsh", RD),
            );

            remove_file(&format!("{}etc/skel/.zshrc.rpmnew", RD), false).ok();
        }

        // Other configs, manually
        // Dropbear
        if _options.config.unsecure_debug {
            Rootfs::execute(
                RD,
                &format!("dnf --assumeyes install dropbear openssh-server"),
                true,
            );
            create_file_symlink(
                "../../boot/rsa_hkey",
                &format!(" {}etc/dropbear/dropbear_rsa_host_key", RD),
            );
            create_file_symlink(
                "../../boot/rsa_hkey.pub",
                &format!(" {}etc/dropbear/dropbear_rsa_host_key.pub", RD),
            );
            Rootfs::disable_service(RD, "sshd");
            Rootfs::disable_service(RD, "sshd.socket");
        }

        // Root password (for now at least)
        if _options.config.unrestricted {
            let pass_hash = run_command_get_output(&format!(
                "openssl passwd -1 {}",
                _options.config.root_password
            ));
            Rootfs::execute(RD, &format!("usermod --password {} root", pass_hash), true);
        }

        // Ssh enabled at default with root login enabled
        /* Dropbear is already running!
        if _options.config.unsecure_debug && _options.config.unrestricted {
            Rootfs::execute(RD, &format!("dnf --assumeyes install sshd"), true);
            Rootfs::execute(RD, &format!("systemctl enable sshd"), true);
            append_to_file(
                &format!("{}etc/ssh/sshd_config", RD),
                "PermitRootLogin yes\n",
            );
        }
        */

        // Other
        replace_string_file(
            &format!("{}etc/os-release", RD),
            "Fedora Linux 42 (Container Image)",
            "Quill OS",
        );

        // Make it not scream errors at boot
        Rootfs::disable_service(RD, "proc-sys-fs-binfmt_misc.mount");
        Rootfs::execute(
            RD,
            "systemd-machine-id-setup",
            _options.config.command_output,
        );

        // Upower hacky fix, make a proper fix in the future!
        // Installed above
        // Rootfs::execute(RD, &format!("dnf --assumeyes install upower"), true);
        let upower_service_file = &format!("{}usr/lib/systemd/system/upower.service", RD);
        let file = read_file_str(upower_service_file.to_string()).unwrap();
        if !file.contains("# PrivateUsers=yes") {
            replace_string_file(
                upower_service_file,
                "PrivateUsers=yes",
                "# PrivateUsers=yes",
            );
        }
        if !file.contains("# RestrictNamespaces=yes") {
            replace_string_file(
                upower_service_file,
                "RestrictNamespaces=yes",
                "# RestrictNamespaces=yes",
            );
        }

        // GUI packages modifications
        // Greetd
        // For tty to not appear with greetd, while running niri - probably not needed anymore
        /*
        for i in 1..8 {
            Rootfs::disable_service(RD, &format!("getty@tty{}.service", i));
        }
        */
        /*
        // Doesn't work :(
        let upower_service_file = &format!("{}usr/lib/systemd/system/greetd.service", RD);
        let file = read_file_str(upower_service_file.to_string()).unwrap();
        if !file.contains("# After=getty@tty1.service") {
            replace_string_file(
                upower_service_file,
                "After=getty@tty1.service",
                "# After=getty@tty1.service",
            );
        }
        if !file.contains("# Conflicts=getty@tty1.service") {
            replace_string_file(
                upower_service_file,
                "Conflicts=getty@tty1.service",
                "# Conflicts=getty@tty1.service",
            );
        }
        */

        // Maybe not needed
        Rootfs::execute(
            RD,
            "usermod -aG video greetd",
            _options.config.command_output,
        );
        Rootfs::execute(
            RD,
            "usermod -aG render greetd",
            _options.config.command_output,
        );

        // Copy modified binary
        copy_file("../greetd/out/greetd", &format!("{}usr/bin/greetd", RD)).unwrap();

        // TODO: add greetd to excludes now

        // Eww
        // We need git
        /*
        Rootfs::execute(
            RD,
            "dnf copr enable varlad/eww -y",
            _options.config.command_output,
        );
        Rootfs::execute(RD, "dnf install eww -y", _options.config.command_output);
        */
        copy_file(
            "../../gui/eww/target/aarch64-unknown-linux-gnu/release/eww",
            &format!("{}usr/bin/eww", RD),
        )
        .unwrap();
        // Eww niri toolbar
        copy_file(
            "../../gui/eww_niri_toolbar/target/aarch64-unknown-linux-gnu/release/eww-niri-taskbar",
            &format!("{}usr/bin/eww-niri-taskbar", RD),
        )
        .unwrap();
        // Eww data provider
        copy_file("../../gui/eww_data_provider/eww-data-provider/target/aarch64-unknown-linux-gnu/release/eww-data-provider", &format!("{}usr/bin/eww-data-provider", RD)).unwrap();
        copy_file("../../gui/eww_data_provider/eww-data-requester/target/aarch64-unknown-linux-gnu/release/eww-data-requester", &format!("{}usr/bin/eww-data-requester", RD)).unwrap();

        // Initial rotation, idk if it's the best way
        // Set in rootfs_config, here we only apply, idk if its needed anyway
        Rootfs::execute(RD, "systemd-hwdb update", _options.config.command_output);

        // Nerd fonts for eww
        Rootfs::execute(
            RD,
            "dnf copr enable che/nerd-fonts -y",
            _options.config.command_output,
        );
        Rootfs::execute(
            RD,
            "dnf install nerd-fonts -y",
            _options.config.command_output,
        );

        // Rnote - welp, doesn't launch
        /*
        Rootfs::execute(
            RD,
            "dnf copr enable fotnite-vevo/rnote fedora-41-aarch64 -y",
            _options.config.command_output,
        );
        Rootfs::execute(RD, "dnf install rnote -y", _options.config.command_output);
        */

        // Anki
        // TODO: In config, based on enums choose what to install
        Rootfs::execute(
            RD,
            "dnf copr enable hazel-bunny/anki -y",
            _options.config.command_output,
        );
        Rootfs::execute(
            RD,
            "dnf install anki-bin -y",
            _options.config.command_output,
        );

        // Niri
        copy_file(
            "../../gui/niri/target/aarch64-unknown-linux-gnu/release/niri",
            &format!("{}usr/bin/niri", RD),
        )
        .unwrap();
        // TODO: Add niri to excludes

        // Koreader
        copy_file(
            "../../gui/koreader/koreader.AppImage",
            &format!("{}usr/bin/koreader.AppImage", RD),
        )
        .unwrap();
        copy_file(
            "../../gui/koreader/koreader.desktop",
            &format!("{}usr/share/applications/koreader.desktop", RD),
        )
        .unwrap();

        // Qoms
        let qoms_dir = &format!("{}opt/qoms/", RD);
        mkdir_p(qoms_dir);
        copy_dir_content("../qoms/out/", qoms_dir);
        // Qoms service
        copy_file(
            "../qoms/other/qoms.service",
            &format!("{}etc/systemd/system/qoms.service", RD),
        )
        .unwrap();
        Rootfs::execute(
            RD,
            "systemctl enable qoms.service",
            _options.config.command_output,
        );

        // Pinenote service
        copy_file(
            "../pinenote_service/target/aarch64-unknown-linux-gnu/release/pinenote-service",
            &format!("{}usr/bin/pinenote-service", RD),
        )
        .unwrap();
        let pinenote_service = &format!("{}etc/systemd/user/pinenote.service", RD);
        copy_file(
            "../pinenote_service/packaging/resources/pinenote.service",
            pinenote_service,
        )
        .unwrap();
        let pinenote_service_str = read_file_str(pinenote_service.to_string()).unwrap();
        if pinenote_service_str.contains("WantedBy=graphical-session.target") {
            replace_string_file(
                pinenote_service,
                "WantedBy=graphical-session.target",
                "WantedBy=default.target",
            );
        }
        copy_file(
            "../pinenote_service/packaging/resources/org.pinenote.PineNoteCtl.service",
            &format!(
                "{}usr/share/dbus-1/services/org.pinenote.PineNoteCtl.service",
                RD
            ),
        )
        .unwrap();
        // Idk if the user preset is needed anymore in rootfs-configs
        Rootfs::execute(
            RD,
            "systemctl --global enable pinenote",
            _options.config.command_output,
        );

        // Squeekboard
        copy_file(
            "../../gui/squeekboard/builddir/src/squeekboard",
            &format!("{}usr/bin/squeekboard", RD),
        )
        .unwrap();

        // Networking
        Rootfs::execute(
            RD,
            "systemctl enable bluetooth",
            _options.config.command_output,
        );

        // Turn off power saving for wireless, it sucks
        std::fs::write(
    format!("{}etc/udev/rules.d/70-wifi-powersave.rules", RD),
    r#"ACTION=="add", SUBSYSTEM=="net", KERNEL=="wlan0", RUN+="/usr/sbin/iw dev wlan0 set power_save off""#).unwrap();
        std::fs::write(
        // Idk if it's needed for bt after all
    format!("{}etc/udev/rules.d/71-bluetooth-powersave.rules", RD),
    r#"ACTION=="add|change", KERNEL=="hci*", SUBSYSTEM=="bluetooth", ATTR{device/power/control}="on""#).unwrap();

        // Cleanout
        umount_recursive(RD);
        remove_files_recursive(RD, ".gitkeep");

        // Compress
        mkdir_p("out");
        remove_file("out/rootfs.squashfs", false).ok();
        remove_file("out/rootfs.squashfs.dgst", false).ok();

        let mksquashfs_cmd = if _options.config.compression_enabled {
            format!(
                "mksquashfs {} out/rootfs.squashfs -b 32768 -comp zstd -Xcompression-level 22 -no-xattrs",
                RD
            )
        } else {
            format!(
                "mksquashfs {} out/rootfs.squashfs -no-compression -no-xattrs",
                RD
            )
        };
        run_command(&mksquashfs_cmd, true).unwrap();
        // Sign
        sign("out/rootfs.squashfs", "out/rootfs.squashfs.dgst", _options);
        Ok(())
    }

    fn deploy(&self, _options: &crate::Options) -> color_eyre::eyre::Result<(), String> {
        warn!("We assume because of expose_mmc deploy, the mmc is exposed as a block device");

        let _disk = choose_disk();
        let partition = get_partition("quill_main");
        mkdir_p("/mnt/quill_main");
        run_command(
            &format!("mount {} /mnt/quill_main", partition),
            _options.config.command_output,
        )
        .unwrap();
        run_command("sync", false).unwrap();
        // Copy things
        mkdir_p("/mnt/quill_main/system");
        remove_file("/mnt/quill_main/system/rootfs.squashfs", false).ok();
        remove_file("/mnt/quill_main/system/rootfs.squashfs.dgst", false).ok();
        copy_file(
            "out/rootfs.squashfs",
            "/mnt/quill_main/system/rootfs.squashfs",
        )
        .unwrap();
        copy_file(
            "out/rootfs.squashfs.dgst",
            "/mnt/quill_main/system/rootfs.squashfs.dgst",
        )
        .unwrap();

        if Confirm::with_theme(&ColorfulTheme::default())
            .with_prompt("Do you want to also clean out RW rootfs?")
            .interact()
            .unwrap()
        {
            remove_dir_all("/mnt/quill_main/system/rootfs").ok();
        }

        if !path_exists("/mnt/quill_main/system/rootfs.squashfs")
            || !path_exists("/mnt/quill_main/system/rootfs.squashfs.dgst")
        {
            panic!("Failed to copy rootfs filesystem to pinenote");
        }

        run_command("sync", false).unwrap();
        run_command(
            &format!("umount {}", partition),
            _options.config.command_output,
        )
        .unwrap();
        Ok(())
    }

    fn run(&self, _options: &Options) -> color_eyre::eyre::Result<(), String> {
        todo!()
    }
}

/*
Command snippets for early rootfs

connect to wifi:
nmcli device wifi list
nmcli device wifi connect "hotspot" password "12345678"
If it refuses to connect for GUI reasons:
nmcli connection delete id "hotspot"
killall nm-applet

Bluetooth keyboard copy line by line:
bluetoothctl
power on
agent on
default-agent
scan on
pair <MAC_ADDRESS>
connect <MAC_ADDRESS>
trust <MAC_ADDRESS>
exit

to mount the encrypted storage from cli:
gocryptfs /home/.szybet /home/szybet

To init the encrypted storage from cli:
mkdir /home/.szybet /home/szybet
gocryptfs -init /home/.szybet

Actually create that user:
useradd szybet
passwd szybet

(Now we need to copy skel there)
gocryptfs /home/.szybet /home/szybet
# This will remove your configurations!
rm -rf /home/szybet/.*
cp -r /etc/skel/.* /home/szybet/
sudo chown -R szybet:szybet /home/szybet # Important permissions
umount /home/szybet

To log in from cli: (Remember to kill quillinit via htop, sort via PID)
also stop qoms:
systemctl stop qoms
export GREETD_SOCK=/run/greetd-X.sock
tuigreetd

Wayland/niri/GUI socket:
export NIRI_SOCKET=/run/user/1000/niri.wayland-X.sock
export WAYLAND_DISPLAY=/run/user/1000/wayland-1
export XDG_RUNTIME_DIR="/run/user/$UID"
export DBUS_SESSION_BUS_ADDRESS="unix:path=${XDG_RUNTIME_DIR}/bus"

To restart niri:
systemctl stop qoms
systemctl stop greetd
killall -9 niri
rm -rf /run/greetd-*.sock
systemctl start greetd
export GREETD_SOCK=/run/greetd-X.sock
tuigreetd
*/
