use std::fs::remove_dir_all;

use crate::prelude::*;

pub const BASE_ROOTFS_URL: &str =
    "https://images.linuxcontainers.org/images/fedora/42/arm64/default/";
pub const ROOTFS_RESOLV_FILE: &str =
    "# Generated by quillstrap\n\nnameserver 1.1.1.1\nnameserver 8.8.8.8\n";

// ZSH is installed in build code seperately in rootfs
const ESSENTIAL_PACKAGES: &[&str] = &["NetworkManager", "NetworkManager-wifi", "cracklib-dicts"];

// Also installed in sysroot
pub const ROOTFS_PACKAGES_EVERYWHERE: &[&str] = &[
    "busybox",
    "htop",
    "vim",
    "nano",
    "nano-default-editor",
    "less",
    "ncurses",
    // Libs
    "libxkbcommon",
    "libinput-utils",
    "libinput",
    "fontconfig",
    "freetype",
    "mesa-libgbm",
    "pam",
    "pam-libs",
];

const ROOTFS_BLACKLIST: &[&str] = &[
    "grub2-*",
    "grubby",
    "kernel-core",
    "kernel-modules",
    "amd-gpu-firmware",
    "intel-gpu-firmware",
    "atheros-firmware",
    "brcmfmac-firmware",
    "iwlwifi-*",
    "libertas-firmware",
    "mt7xxx-firmware",
    "nvidia-gpu-firmware",
    "nxpwireless-firmware",
    "qcom-firmware",
    "qcom-wwan-firmware",
    "realtek-firmware",
    "tiwilink-firmware",
    "intel-audio-firmware",
    "cirrus-audio-firmware",
    "linux-firmware",
    "amd-ucode-firmware",
    "xorg-x11-drv-amdgpu",
    "xorg-x11-drv-ati",
    "xorg-x11-drv-nouveau",
    "xorg-x11-drv-qxl",
    "xorg-x11-drv-wacom",
    "dracut*",
    "fwupd*",
    "plymouth*",
    "zram-generator*",
    "open-vm-tools*",
    "qemu-guest-agent",
    "qemu-img",
    "selinux*",
];

const ROOTFS_GUI_PACKAGES: &[&str] = &["greetd", "niri", "upower", "alacritty"];

#[derive(Clone, Copy, Default)]
pub struct Rootfs;

impl Rootfs {
    pub fn execute(dir: &str, command: &str, show_output: bool) {
        // let thing = get_thing_by_name("rootfs", &_options.things);
        let cur_dir = dir_current();
        run_command(&format!("chroot {} {}", dir, command), show_output).unwrap();
        dir_change(&cur_dir);
    }

    // Dir, with / at the end
    pub fn turn_on_chroot(dir: &str) {
        umount_recursive(dir);
        mount_point(&format!("{}proc", dir), "proc");
        mount_point(&format!("{}sys", dir), "sysfs");
        mount_point(&format!("{}tmp", dir), "tmpfs");
        mount_point(&format!("{}run", dir), "tmpfs");
        mount_point(&format!("{}dev", dir), "devtmpfs");
        /*
        let dev_pts_path = &format!("{}dev/pts", dir);
        mkdir_p(dev_pts_path);
        mount_point(dev_pts_path, "devpts");
        */
        let resolv_file = &format!("{}/etc/resolv.conf", dir);
        remove_file(resolv_file, false).ok();
        let mut file = File::create(resolv_file).unwrap();
        file.write_all(ROOTFS_RESOLV_FILE.as_bytes()).unwrap();
        file.flush().unwrap();
    }

    pub fn disable_service(dir: &str, service: &str) {
        Rootfs::execute(dir, &format!("systemctl disable {}", service), false);
        Rootfs::execute(dir, &format!("systemctl mask {}", service), false);
    }
}

impl SetupThing for Rootfs {
    fn name(&self) -> &'static str {
        "rootfs"
    }

    fn path(&self) -> &'static str {
        "os/low/"
    }

    fn deps(&self) -> Vec<&'static str> {
        vec!["rootfs_configs", "greetd"]
    }

    fn git(&self) -> &'static str {
        todo!()
    }

    fn get(&self, _options: &crate::Options) -> color_eyre::eyre::Result<(), String> {
        mkdir_p(self.name());
        dir_change(self.name());

        if path_exists("rootfs.tar.xz") && path_exists("rootfs") {
            warn!(
                "Rootfs file and dir already present. We won't redownload them, use clean if you want to force this"
            );
            dir_change("../");
            return Ok(());
        }

        remove_file("rootfs.tar.xz", false).ok();
        remove_dir_all("rootfs").ok();

        let mut ver = run_shell_command_get_output(&format!(
            "curl -s {} | grep href | tail -n 3 | cut -c 10-25 | tail -n 1",
            BASE_ROOTFS_URL
        ));
        ver.pop();
        info!("Downloading container version: {}", ver);
        download_file(
            &format!("{}{}/rootfs.tar.xz", BASE_ROOTFS_URL, ver),
            "rootfs.tar.xz",
        );

        mkdir_p("rootfs");
        run_command(
            &format!("tar -xJf rootfs.tar.xz -C rootfs"),
            _options.config.command_output,
        )
        .unwrap();

        dir_change("../");
        Ok(())
    }

    fn clean(&self) -> color_eyre::eyre::Result<(), String> {
        remove_dir_all("rootfs/").ok();
        remove_file("rootfs.tar.xz", true).ok();

        Ok(())
    }

    fn build(&self, _options: &crate::Options) -> color_eyre::eyre::Result<(), String> {
        warn!(
            "This is an additive build, if you builded it before with different features, you should clean it now!"
        );

        const RD: &str = "rootfs/";
        Rootfs::turn_on_chroot(RD);

        // Configs from other repo
        copy_dir_content("../rootfs_configs/common", RD);
        if _options.config.unrestricted {
            copy_dir_content("../rootfs_configs/unrestricted", RD);
        } else {
            copy_dir_content("../rootfs_configs/restricted", RD);
        }
        // Copy skel dir to root
        copy_dir_content("../rootfs_configs/common/etc/skel", &format!("{}root/", RD));

        // Apply dnf blacklist
        append_to_file(
            &format!("{}etc/dnf/dnf.conf", RD),
            &format!("exclude=\"{}\"", ROOTFS_BLACKLIST.join(",")),
        );

        // Packages
        Rootfs::execute(RD, "dnf --assumeyes update", true);
        let mut packages = Vec::from(ESSENTIAL_PACKAGES);
        packages.extend(ROOTFS_PACKAGES_EVERYWHERE);
        packages.extend(ROOTFS_GUI_PACKAGES);
        Rootfs::execute(
            RD,
            &format!("dnf --assumeyes install {}", packages.join(" ")),
            true,
        );

        // Files and dirs
        // For now, no
        /*
        if _options.config.unrestricted {
            File::create(&format!("{}.unrestricted", RD)).unwrap();
        }
        */
        mkdir_p(&format!("{}lib/modules", RD));
        mkdir_p(&format!("{}lib/firmware", RD));
        clean_dir(&format!("{}var/log", RD));
        clean_dir(&format!("{}var/cache", RD));

        // Services
        Rootfs::disable_service(RD, "systemd-networkd-wait-online");
        Rootfs::disable_service(RD, "systemd-time-wait-sync");
        Rootfs::disable_service(RD, "serial-getty@");
        Rootfs::disable_service(RD, "getty@tty1");

        // Zsh
        {
            Rootfs::execute(
                RD,
                &format!(
                    "dnf config-manager addrepo --from-repofile=https://download.opensuse.org/repositories/shells:zsh-users:zsh-autosuggestions/Fedora_Rawhide/shells:zsh-users:zsh-autosuggestions.repo"
                ),
                _options.config.command_output,
            );
            Rootfs::execute(
                RD,
                &format!("dnf --assumeyes install zsh zsh-autosuggestions"),
                _options.config.command_output,
            );
            Rootfs::execute(RD, &format!("chsh -s /usr/bin/zsh root"), true);
            mkdir_p(&format!("{}etc/zsh/zsh-autosuggestions", RD));
            create_file_symlink(
                "/usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh",
                &format!("{}etc/zsh/zsh-autosuggestions/zsh-autosuggestions.zsh", RD),
            );

            remove_file(&format!("{}etc/skel/.zshrc.rpmnew", RD), false).ok();
        }

        // Other configs, manually
        // Dropbear
        if _options.config.unsecure_debug {
            Rootfs::execute(
                RD,
                &format!("dnf --assumeyes install dropbear openssh-server"),
                true,
            );
            create_file_symlink(
                "../../boot/rsa_hkey",
                &format!(" {}etc/dropbear/dropbear_rsa_host_key", RD),
            );
            create_file_symlink(
                "../../boot/rsa_hkey.pub",
                &format!(" {}etc/dropbear/dropbear_rsa_host_key.pub", RD),
            );
            Rootfs::disable_service(RD, "sshd");
            Rootfs::disable_service(RD, "sshd.socket");
        }

        // Root password (for now at least)
        if _options.config.unrestricted {
            let pass_hash = run_command_get_output(&format!(
                "openssl passwd -1 {}",
                _options.config.root_password
            ));
            Rootfs::execute(RD, &format!("usermod --password {} root", pass_hash), true);
        }

        // Ssh enabled at default with root login enabled
        /* Dropbear is already running!
        if _options.config.unsecure_debug && _options.config.unrestricted {
            Rootfs::execute(RD, &format!("dnf --assumeyes install sshd"), true);
            Rootfs::execute(RD, &format!("systemctl enable sshd"), true);
            append_to_file(
                &format!("{}etc/ssh/sshd_config", RD),
                "PermitRootLogin yes\n",
            );
        }
        */

        // Other
        replace_string_file(
            &format!("{}etc/os-release", RD),
            "Fedora Linux 42 (Container Image)",
            "Quill OS",
        );

        // Make it not scream errors at boot
        Rootfs::disable_service(RD, "proc-sys-fs-binfmt_misc.mount");
        Rootfs::execute(
            RD,
            "systemd-machine-id-setup",
            _options.config.command_output,
        );

        // Upower hacky fix, make a proper fix in the future!
        // Installed above
        // Rootfs::execute(RD, &format!("dnf --assumeyes install upower"), true);
        let upower_service_file = &format!("{}usr/lib/systemd/system/upower.service", RD);
        let file = read_file_str(upower_service_file.to_string()).unwrap();
        if !file.contains("# PrivateUsers=yes") {
            replace_string_file(
                upower_service_file,
                "PrivateUsers=yes",
                "# PrivateUsers=yes",
            );
        }
        if !file.contains("# RestrictNamespaces=yes") {
            replace_string_file(
                upower_service_file,
                "RestrictNamespaces=yes",
                "# RestrictNamespaces=yes",
            );
        }

        // GUI packages modifications
        {
            // For tty to not appear with greetd, while running niri
            for i in 1..8 {
                Rootfs::disable_service(RD, &format!("getty@tty{}.service", i));
            }
            let upower_service_file = &format!("{}usr/lib/systemd/system/greetd.service", RD);
            let file = read_file_str(upower_service_file.to_string()).unwrap();
            if !file.contains("# After=getty@tty1.service") {
                replace_string_file(
                    upower_service_file,
                    "After=getty@tty1.service",
                    "# After=getty@tty1.service",
                );
            }
            if !file.contains("# Conflicts=getty@tty1.service") {
                replace_string_file(
                    upower_service_file,
                    "Conflicts=getty@tty1.service",
                    "# Conflicts=getty@tty1.service",
                );
            }
            // Maybe not needed
            Rootfs::execute(
                RD,
                "usermod -aG video greetd",
                _options.config.command_output,
            );
            Rootfs::execute(
                RD,
                "usermod -aG render greetd",
                _options.config.command_output,
            );

            // Copy modified binary
            copy_file("../greetd/out/greetd", &format!("{}usr/bin/greetd", RD)).unwrap();

            // Modify config
            let greetd_config = &format!("{}etc/greetd/config.toml", RD);
            let file = read_file_str(greetd_config.to_string()).unwrap();
            if file.contains("agreety --cmd /bin/sh") {
                replace_string_file(greetd_config, "agreety --cmd /bin/sh", "sleep infinity");
            }
        }

        // Cleanout
        umount_recursive(RD);
        remove_files_recursive(RD, ".gitkeep");

        // Compress
        mkdir_p("out");
        remove_file("out/rootfs.squashfs", false).ok();
        remove_file("out/rootfs.squashfs.dgst", false).ok();

        run_command(&format!("mksquashfs {} out/rootfs.squashfs -b 32768 -comp zstd -Xcompression-level 22 -no-xattrs", RD), true).unwrap();
        // Sign
        sign("out/rootfs.squashfs", "out/rootfs.squashfs.dgst", _options);
        Ok(())
    }

    fn deploy(&self, _options: &crate::Options) -> color_eyre::eyre::Result<(), String> {
        warn!("We assume because of expose_mmc deploy, the mmc is exposed as a block device");

        let _disk = choose_disk();
        let partition = get_partition("quill_main");
        mkdir_p("/mnt/quill_main");
        run_command(
            &format!("mount {} /mnt/quill_main", partition),
            _options.config.command_output,
        )
        .unwrap();
        run_command("sync", false).unwrap();
        // Copy things
        mkdir_p("/mnt/quill_main/system");
        remove_file("/mnt/quill_main/system/rootfs.squashfs", false).ok();
        remove_file("/mnt/quill_main/system/rootfs.squashfs.dgst", false).ok();
        copy_file(
            "out/rootfs.squashfs",
            "/mnt/quill_main/system/rootfs.squashfs",
        )
        .unwrap();
        copy_file(
            "out/rootfs.squashfs.dgst",
            "/mnt/quill_main/system/rootfs.squashfs.dgst",
        )
        .unwrap();

        if Confirm::with_theme(&ColorfulTheme::default())
            .with_prompt("Do you want to also clean out RW rootfs?")
            .interact()
            .unwrap()
        {
            remove_dir_all("/mnt/quill_main/system/rootfs").ok();
        }

        if !path_exists("/mnt/quill_main/system/rootfs.squashfs")
            || !path_exists("/mnt/quill_main/system/rootfs.squashfs.dgst")
        {
            panic!("Failed to copy rootfs filesystem to pinenote");
        }

        run_command("sync", false).unwrap();
        run_command(
            &format!("umount {}", partition),
            _options.config.command_output,
        )
        .unwrap();
        Ok(())
    }

    fn run(&self) -> color_eyre::eyre::Result<(), String> {
        todo!()
    }
}

/*
Command snippets for early rootfs

connect to wifi:
nmcli device wifi list
nmcli device wifi connect "hotspot" password "12345678"
*/
